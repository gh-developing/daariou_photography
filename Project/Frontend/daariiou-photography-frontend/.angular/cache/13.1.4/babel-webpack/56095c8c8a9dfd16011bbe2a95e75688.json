{"ast":null,"code":"/*!\n * lightgallery | 2.3.0 | October 28th 2021\n * http://www.lightgalleryjs.com/\n * Copyright (c) 2020 Sachin Neravath;\n * @license GPLv3\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar zoomSettings = {\n  scale: 1,\n  zoom: true,\n  actualSize: true,\n  showZoomInOutIcons: false,\n  actualSizeIcons: {\n    zoomIn: 'lg-zoom-in',\n    zoomOut: 'lg-zoom-out'\n  },\n  enableZoomAfter: 300\n};\n/**\r\n * List of lightGallery events\r\n * All events should be documented here\r\n * Below interfaces are used to build the website documentations\r\n * */\n\nvar lGEvents = {\n  afterAppendSlide: 'lgAfterAppendSlide',\n  init: 'lgInit',\n  hasVideo: 'lgHasVideo',\n  containerResize: 'lgContainerResize',\n  updateSlides: 'lgUpdateSlides',\n  afterAppendSubHtml: 'lgAfterAppendSubHtml',\n  beforeOpen: 'lgBeforeOpen',\n  afterOpen: 'lgAfterOpen',\n  slideItemLoad: 'lgSlideItemLoad',\n  beforeSlide: 'lgBeforeSlide',\n  afterSlide: 'lgAfterSlide',\n  posterClick: 'lgPosterClick',\n  dragStart: 'lgDragStart',\n  dragMove: 'lgDragMove',\n  dragEnd: 'lgDragEnd',\n  beforeNextSlide: 'lgBeforeNextSlide',\n  beforePrevSlide: 'lgBeforePrevSlide',\n  beforeClose: 'lgBeforeClose',\n  afterClose: 'lgAfterClose',\n  rotateLeft: 'lgRotateLeft',\n  rotateRight: 'lgRotateRight',\n  flipHorizontal: 'lgFlipHorizontal',\n  flipVertical: 'lgFlipVertical'\n};\n\nvar Zoom =\n/** @class */\nfunction () {\n  function Zoom(instance, $LG) {\n    // get lightGallery core plugin instance\n    this.core = instance;\n    this.$LG = $LG;\n    this.settings = __assign(__assign({}, zoomSettings), this.core.settings);\n    return this;\n  } // Append Zoom controls. Actual size, Zoom-in, Zoom-out\n\n\n  Zoom.prototype.buildTemplates = function () {\n    var zoomIcons = this.settings.showZoomInOutIcons ? \"<button id=\\\"\" + this.core.getIdName('lg-zoom-in') + \"\\\" type=\\\"button\\\" aria-label=\\\"Zoom in\\\" class=\\\"lg-zoom-in lg-icon\\\"></button><button id=\\\"\" + this.core.getIdName('lg-zoom-out') + \"\\\" type=\\\"button\\\" aria-label=\\\"Zoom out\\\" class=\\\"lg-zoom-out lg-icon\\\"></button>\" : '';\n\n    if (this.settings.actualSize) {\n      zoomIcons += \"<button id=\\\"\" + this.core.getIdName('lg-actual-size') + \"\\\" type=\\\"button\\\" aria-label=\\\"View actual size\\\" class=\\\"\" + this.settings.actualSizeIcons.zoomIn + \" lg-icon\\\"></button>\";\n    }\n\n    this.core.outer.addClass('lg-use-transition-for-zoom');\n    this.core.$toolbar.first().append(zoomIcons);\n  };\n  /**\r\n   * @desc Enable zoom option only once the image is completely loaded\r\n   * If zoomFromOrigin is true, Zoom is enabled once the dummy image has been inserted\r\n   *\r\n   * Zoom styles are defined under lg-zoomable CSS class.\r\n   */\n\n\n  Zoom.prototype.enableZoom = function (event) {\n    var _this = this; // delay will be 0 except first time\n\n\n    var _speed = this.settings.enableZoomAfter + event.detail.delay; // set _speed value 0 if gallery opened from direct url and if it is first slide\n\n\n    if (this.$LG('body').first().hasClass('lg-from-hash') && event.detail.delay) {\n      // will execute only once\n      _speed = 0;\n    } else {\n      // Remove lg-from-hash to enable starting animation.\n      this.$LG('body').first().removeClass('lg-from-hash');\n    }\n\n    this.zoomableTimeout = setTimeout(function () {\n      if (!_this.isImageSlide()) {\n        return;\n      }\n\n      _this.core.getSlideItem(event.detail.index).addClass('lg-zoomable');\n\n      if (event.detail.index === _this.core.index) {\n        _this.setZoomEssentials();\n      }\n    }, _speed + 30);\n  };\n\n  Zoom.prototype.enableZoomOnSlideItemLoad = function () {\n    // Add zoomable class\n    this.core.LGel.on(lGEvents.slideItemLoad + \".zoom\", this.enableZoom.bind(this));\n  };\n\n  Zoom.prototype.getModifier = function (rotateValue, axis, el) {\n    var originalRotate = rotateValue;\n    rotateValue = Math.abs(rotateValue);\n    var transformValues = this.getCurrentTransform(el);\n\n    if (!transformValues) {\n      return 1;\n    }\n\n    var modifier = 1;\n\n    if (axis === 'X') {\n      var flipHorizontalValue = Math.sign(parseFloat(transformValues[0]));\n\n      if (rotateValue === 0 || rotateValue === 180) {\n        modifier = 1;\n      } else if (rotateValue === 90) {\n        if (originalRotate === -90 && flipHorizontalValue === 1 || originalRotate === 90 && flipHorizontalValue === -1) {\n          modifier = -1;\n        } else {\n          modifier = 1;\n        }\n      }\n\n      modifier = modifier * flipHorizontalValue;\n    } else {\n      var flipVerticalValue = Math.sign(parseFloat(transformValues[3]));\n\n      if (rotateValue === 0 || rotateValue === 180) {\n        modifier = 1;\n      } else if (rotateValue === 90) {\n        var sinX = parseFloat(transformValues[1]);\n        var sinMinusX = parseFloat(transformValues[2]);\n        modifier = Math.sign(sinX * sinMinusX * originalRotate * flipVerticalValue);\n      }\n\n      modifier = modifier * flipVerticalValue;\n    }\n\n    return modifier;\n  };\n\n  Zoom.prototype.getImageSize = function ($image, rotateValue, axis) {\n    var imageSizes = {\n      y: 'offsetHeight',\n      x: 'offsetWidth'\n    };\n\n    if (Math.abs(rotateValue) === 90) {\n      // Swap axis\n      if (axis === 'x') {\n        axis = 'y';\n      } else {\n        axis = 'x';\n      }\n    }\n\n    return $image[imageSizes[axis]];\n  };\n\n  Zoom.prototype.getDragCords = function (e, rotateValue) {\n    if (rotateValue === 90) {\n      return {\n        x: e.pageY,\n        y: e.pageX\n      };\n    } else {\n      return {\n        x: e.pageX,\n        y: e.pageY\n      };\n    }\n  };\n\n  Zoom.prototype.getSwipeCords = function (e, rotateValue) {\n    var x = e.targetTouches[0].pageX;\n    var y = e.targetTouches[0].pageY;\n\n    if (rotateValue === 90) {\n      return {\n        x: y,\n        y: x\n      };\n    } else {\n      return {\n        x: x,\n        y: y\n      };\n    }\n  };\n\n  Zoom.prototype.getDragAllowedAxises = function (rotateValue, scale) {\n    scale = scale || this.scale || 1;\n    var allowY = this.imageYSize * scale > this.containerRect.height;\n    var allowX = this.imageXSize * scale > this.containerRect.width;\n\n    if (rotateValue === 90) {\n      return {\n        allowX: allowY,\n        allowY: allowX\n      };\n    } else {\n      return {\n        allowX: allowX,\n        allowY: allowY\n      };\n    }\n  };\n  /**\r\n   *\r\n   * @param {Element} el\r\n   * @return matrix(cos(X), sin(X), -sin(X), cos(X), 0, 0);\r\n   * Get the current transform value\r\n   */\n\n\n  Zoom.prototype.getCurrentTransform = function (el) {\n    if (!el) {\n      return;\n    }\n\n    var st = window.getComputedStyle(el, null);\n    var tm = st.getPropertyValue('-webkit-transform') || st.getPropertyValue('-moz-transform') || st.getPropertyValue('-ms-transform') || st.getPropertyValue('-o-transform') || st.getPropertyValue('transform') || 'none';\n\n    if (tm !== 'none') {\n      return tm.split('(')[1].split(')')[0].split(',');\n    }\n\n    return;\n  };\n\n  Zoom.prototype.getCurrentRotation = function (el) {\n    if (!el) {\n      return 0;\n    }\n\n    var values = this.getCurrentTransform(el);\n\n    if (values) {\n      return Math.round(Math.atan2(parseFloat(values[1]), parseFloat(values[0])) * (180 / Math.PI)); // If you want rotate in 360\n      //return (angle < 0 ? angle + 360 : angle);\n    }\n\n    return 0;\n  };\n\n  Zoom.prototype.setZoomEssentials = function () {\n    var $image = this.core.getSlideItem(this.core.index).find('.lg-image').first();\n    var rotateEl = this.core.getSlideItem(this.core.index).find('.lg-img-rotate').first().get();\n    this.rotateValue = this.getCurrentRotation(rotateEl);\n    this.imageYSize = this.getImageSize($image.get(), this.rotateValue, 'y');\n    this.imageXSize = this.getImageSize($image.get(), this.rotateValue, 'x');\n    this.containerRect = this.core.outer.get().getBoundingClientRect();\n    this.modifierX = this.getModifier(this.rotateValue, 'X', rotateEl);\n    this.modifierY = this.getModifier(this.rotateValue, 'Y', rotateEl);\n  };\n  /**\r\n   * @desc Image zoom\r\n   * Translate the wrap and scale the image to get better user experience\r\n   *\r\n   * @param {String} scale - Zoom decrement/increment value\r\n   */\n\n\n  Zoom.prototype.zoomImage = function (scale) {\n    // Find offset manually to avoid issue after zoom\n    var offsetX = (this.containerRect.width - this.imageXSize) / 2 + this.containerRect.left;\n    var _a = this.core.mediaContainerPosition,\n        top = _a.top,\n        bottom = _a.bottom;\n    var topBottomSpacing = Math.abs(top - bottom) / 2;\n    var offsetY = (this.containerRect.height - this.imageYSize - topBottomSpacing * this.modifierX) / 2 + this.scrollTop + this.containerRect.top;\n    var originalX;\n    var originalY;\n\n    if (scale === 1) {\n      this.positionChanged = false;\n    }\n\n    var dragAllowedAxises = this.getDragAllowedAxises(Math.abs(this.rotateValue), scale);\n    var allowY = dragAllowedAxises.allowY,\n        allowX = dragAllowedAxises.allowX;\n\n    if (this.positionChanged) {\n      originalX = this.left / (this.scale - 1);\n      originalY = this.top / (this.scale - 1);\n      this.pageX = Math.abs(originalX) + offsetX;\n      this.pageY = Math.abs(originalY) + offsetY;\n      this.positionChanged = false;\n    }\n\n    var possibleSwipeCords = this.getPossibleSwipeDragCords(this.rotateValue, scale);\n\n    var _x = offsetX - this.pageX;\n\n    var _y = offsetY - this.pageY;\n\n    var x = (scale - 1) * _x;\n    var y = (scale - 1) * _y;\n\n    if (allowX) {\n      if (this.isBeyondPossibleLeft(x, possibleSwipeCords.minX)) {\n        x = possibleSwipeCords.minX;\n      } else if (this.isBeyondPossibleRight(x, possibleSwipeCords.maxX)) {\n        x = possibleSwipeCords.maxX;\n      }\n    } else {\n      if (scale > 1) {\n        if (x < possibleSwipeCords.minX) {\n          x = possibleSwipeCords.minX;\n        } else if (x > possibleSwipeCords.maxX) {\n          x = possibleSwipeCords.maxX;\n        }\n      }\n    }\n\n    if (allowY) {\n      if (this.isBeyondPossibleTop(y, possibleSwipeCords.minY)) {\n        y = possibleSwipeCords.minY;\n      } else if (this.isBeyondPossibleBottom(y, possibleSwipeCords.maxY)) {\n        y = possibleSwipeCords.maxY;\n      }\n    } else {\n      // If the translate value based on index of beyond the viewport, utilize the available space to prevent image being cut out\n      if (scale > 1) {\n        //If image goes beyond viewport top, use the minim possible translate value\n        if (y < possibleSwipeCords.minY) {\n          y = possibleSwipeCords.minY;\n        } else if (y > possibleSwipeCords.maxY) {\n          y = possibleSwipeCords.maxY;\n        }\n      }\n    }\n\n    this.setZoomStyles({\n      x: x,\n      y: y,\n      scale: scale\n    });\n  };\n  /**\r\n   * @desc apply scale3d to image and translate to image wrap\r\n   * @param {style} X,Y and scale\r\n   */\n\n\n  Zoom.prototype.setZoomStyles = function (style) {\n    var $image = this.core.getSlideItem(this.core.index).find('.lg-image').first();\n    var $dummyImage = this.core.outer.find('.lg-current .lg-dummy-img').first();\n    var $imageWrap = $image.parent();\n    this.scale = style.scale;\n    $image.css('transform', 'scale3d(' + style.scale + ', ' + style.scale + ', 1)');\n    $dummyImage.css('transform', 'scale3d(' + style.scale + ', ' + style.scale + ', 1)');\n    var transform = 'translate3d(' + style.x + 'px, ' + style.y + 'px, 0)';\n    $imageWrap.css('transform', transform);\n    this.left = style.x;\n    this.top = style.y;\n  };\n  /**\r\n   * @param index - Index of the current slide\r\n   * @param event - event will be available only if the function is called on clicking/taping the imags\r\n   */\n\n\n  Zoom.prototype.setActualSize = function (index, event) {\n    var _this = this; // Allow zoom only on image\n\n\n    if (!this.isImageSlide() || this.core.outer.hasClass('lg-first-slide-loading')) {\n      return;\n    }\n\n    var scale = this.getCurrentImageActualSizeScale();\n\n    if (this.core.outer.hasClass('lg-zoomed')) {\n      this.scale = 1;\n    } else {\n      this.scale = this.getScale(scale);\n    }\n\n    this.setPageCords(event);\n    this.beginZoom(this.scale);\n    this.zoomImage(this.scale);\n    setTimeout(function () {\n      _this.core.outer.removeClass('lg-grabbing').addClass('lg-grab');\n    }, 10);\n  };\n\n  Zoom.prototype.getNaturalWidth = function (index) {\n    var $image = this.core.getSlideItem(index).find('.lg-image').first();\n    var naturalWidth = this.core.galleryItems[index].width;\n    return naturalWidth ? parseFloat(naturalWidth) : $image.get().naturalWidth;\n  };\n\n  Zoom.prototype.getActualSizeScale = function (naturalWidth, width) {\n    var _scale;\n\n    var scale;\n\n    if (naturalWidth > width) {\n      _scale = naturalWidth / width;\n      scale = _scale || 2;\n    } else {\n      scale = 1;\n    }\n\n    return scale;\n  };\n\n  Zoom.prototype.getCurrentImageActualSizeScale = function () {\n    var $image = this.core.getSlideItem(this.core.index).find('.lg-image').first();\n    var width = $image.get().offsetWidth;\n    var naturalWidth = this.getNaturalWidth(this.core.index) || width;\n    return this.getActualSizeScale(naturalWidth, width);\n  };\n\n  Zoom.prototype.getPageCords = function (event) {\n    var cords = {};\n\n    if (event) {\n      cords.x = event.pageX || event.targetTouches[0].pageX;\n      cords.y = event.pageY || event.targetTouches[0].pageY;\n    } else {\n      var containerRect = this.core.outer.get().getBoundingClientRect();\n      cords.x = containerRect.width / 2 + containerRect.left;\n      cords.y = containerRect.height / 2 + this.scrollTop + containerRect.top;\n    }\n\n    return cords;\n  };\n\n  Zoom.prototype.setPageCords = function (event) {\n    var pageCords = this.getPageCords(event);\n    this.pageX = pageCords.x;\n    this.pageY = pageCords.y;\n  }; // If true, zoomed - in else zoomed out\n\n\n  Zoom.prototype.beginZoom = function (scale) {\n    this.core.outer.removeClass('lg-zoom-drag-transition lg-zoom-dragging');\n\n    if (scale > 1) {\n      this.core.outer.addClass('lg-zoomed');\n      var $actualSize = this.core.getElementById('lg-actual-size');\n      $actualSize.removeClass(this.settings.actualSizeIcons.zoomIn).addClass(this.settings.actualSizeIcons.zoomOut);\n    } else {\n      this.resetZoom();\n    }\n\n    return scale > 1;\n  };\n\n  Zoom.prototype.getScale = function (scale) {\n    var actualSizeScale = this.getCurrentImageActualSizeScale();\n\n    if (scale < 1) {\n      scale = 1;\n    } else if (scale > actualSizeScale) {\n      scale = actualSizeScale;\n    }\n\n    return scale;\n  };\n\n  Zoom.prototype.init = function () {\n    var _this = this;\n\n    if (!this.settings.zoom) {\n      return;\n    }\n\n    this.buildTemplates();\n    this.enableZoomOnSlideItemLoad();\n    var tapped = null;\n    this.core.outer.on('dblclick.lg', function (event) {\n      if (!_this.$LG(event.target).hasClass('lg-image')) {\n        return;\n      }\n\n      _this.setActualSize(_this.core.index, event);\n    });\n    this.core.outer.on('touchstart.lg', function (event) {\n      var $target = _this.$LG(event.target);\n\n      if (event.targetTouches.length === 1 && $target.hasClass('lg-image')) {\n        if (!tapped) {\n          tapped = setTimeout(function () {\n            tapped = null;\n          }, 300);\n        } else {\n          clearTimeout(tapped);\n          tapped = null;\n          event.preventDefault();\n\n          _this.setActualSize(_this.core.index, event);\n        }\n      }\n    }); // Update zoom on resize and orientationchange\n\n    this.core.LGel.on(lGEvents.containerResize + \".zoom \" + lGEvents.rotateRight + \".zoom \" + lGEvents.rotateLeft + \".zoom \" + lGEvents.flipHorizontal + \".zoom \" + lGEvents.flipVertical + \".zoom\", function () {\n      if (!_this.core.lgOpened || !_this.isImageSlide()) return;\n\n      _this.setPageCords();\n\n      _this.setZoomEssentials();\n\n      _this.zoomImage(_this.scale);\n    }); // Update zoom on resize and orientationchange\n\n    this.$LG(window).on(\"scroll.lg.zoom.global\" + this.core.lgId, function () {\n      if (!_this.core.lgOpened) return;\n      _this.scrollTop = _this.$LG(window).scrollTop();\n    });\n    this.core.getElementById('lg-zoom-out').on('click.lg', function () {\n      if (_this.core.outer.find('.lg-current .lg-image').get()) {\n        _this.scale -= _this.settings.scale;\n        _this.scale = _this.getScale(_this.scale);\n\n        _this.beginZoom(_this.scale);\n\n        _this.zoomImage(_this.scale);\n      }\n    });\n    this.core.getElementById('lg-zoom-in').on('click.lg', function () {\n      _this.zoomIn();\n    });\n    this.core.getElementById('lg-actual-size').on('click.lg', function () {\n      _this.setActualSize(_this.core.index);\n    });\n    this.core.LGel.on(lGEvents.beforeOpen + \".zoom\", function () {\n      _this.core.outer.find('.lg-item').removeClass('lg-zoomable');\n    });\n    this.core.LGel.on(lGEvents.afterOpen + \".zoom\", function () {\n      _this.scrollTop = _this.$LG(window).scrollTop(); // Set the initial value center\n\n      _this.pageX = _this.core.outer.width() / 2;\n      _this.pageY = _this.core.outer.height() / 2 + _this.scrollTop;\n      _this.scale = 1;\n    }); // Reset zoom on slide change\n\n    this.core.LGel.on(lGEvents.afterSlide + \".zoom\", function (event) {\n      var prevIndex = event.detail.prevIndex;\n      _this.scale = 1;\n      _this.positionChanged = false;\n\n      _this.resetZoom(prevIndex);\n\n      if (_this.isImageSlide()) {\n        _this.setZoomEssentials();\n      }\n    }); // Drag option after zoom\n\n    this.zoomDrag();\n    this.pinchZoom();\n    this.zoomSwipe(); // Store the zoomable timeout value just to clear it while closing\n\n    this.zoomableTimeout = false;\n    this.positionChanged = false;\n  };\n\n  Zoom.prototype.zoomIn = function (scale) {\n    // Allow zoom only on image\n    if (!this.isImageSlide()) {\n      return;\n    }\n\n    if (scale) {\n      this.scale = scale;\n    } else {\n      this.scale += this.settings.scale;\n    }\n\n    this.scale = this.getScale(this.scale);\n    this.beginZoom(this.scale);\n    this.zoomImage(this.scale);\n  }; // Reset zoom effect\n\n\n  Zoom.prototype.resetZoom = function (index) {\n    this.core.outer.removeClass('lg-zoomed lg-zoom-drag-transition');\n    var $actualSize = this.core.getElementById('lg-actual-size');\n    var $item = this.core.getSlideItem(index !== undefined ? index : this.core.index);\n    $actualSize.removeClass(this.settings.actualSizeIcons.zoomOut).addClass(this.settings.actualSizeIcons.zoomIn);\n    $item.find('.lg-img-wrap').first().removeAttr('style');\n    $item.find('.lg-image').first().removeAttr('style');\n    this.scale = 1;\n    this.left = 0;\n    this.top = 0; // Reset pagx pagy values to center\n\n    this.setPageCords();\n  };\n\n  Zoom.prototype.getTouchDistance = function (e) {\n    return Math.sqrt((e.targetTouches[0].pageX - e.targetTouches[1].pageX) * (e.targetTouches[0].pageX - e.targetTouches[1].pageX) + (e.targetTouches[0].pageY - e.targetTouches[1].pageY) * (e.targetTouches[0].pageY - e.targetTouches[1].pageY));\n  };\n\n  Zoom.prototype.pinchZoom = function () {\n    var _this = this;\n\n    var startDist = 0;\n    var pinchStarted = false;\n    var initScale = 1;\n    var $item = this.core.getSlideItem(this.core.index);\n    this.core.$inner.on('touchstart.lg', function (e) {\n      $item = _this.core.getSlideItem(_this.core.index);\n\n      if (!_this.isImageSlide()) {\n        return;\n      }\n\n      if (e.targetTouches.length === 2 && !_this.core.outer.hasClass('lg-first-slide-loading') && (_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target))) {\n        initScale = _this.scale || 1;\n\n        _this.core.outer.removeClass('lg-zoom-drag-transition lg-zoom-dragging');\n\n        _this.core.touchAction = 'pinch';\n        startDist = _this.getTouchDistance(e);\n      }\n    });\n    this.core.$inner.on('touchmove.lg', function (e) {\n      if (e.targetTouches.length === 2 && _this.core.touchAction === 'pinch' && (_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target))) {\n        e.preventDefault();\n\n        var endDist = _this.getTouchDistance(e);\n\n        var distance = startDist - endDist;\n\n        if (!pinchStarted && Math.abs(distance) > 5) {\n          pinchStarted = true;\n        }\n\n        if (pinchStarted) {\n          _this.scale = Math.max(1, initScale + -distance * 0.008);\n\n          _this.zoomImage(_this.scale);\n        }\n      }\n    });\n    this.core.$inner.on('touchend.lg', function (e) {\n      if (_this.core.touchAction === 'pinch' && (_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target))) {\n        pinchStarted = false;\n        startDist = 0;\n\n        if (_this.scale <= 1) {\n          _this.resetZoom();\n        } else {\n          _this.scale = _this.getScale(_this.scale);\n\n          _this.zoomImage(_this.scale);\n\n          _this.core.outer.addClass('lg-zoomed');\n        }\n\n        _this.core.touchAction = undefined;\n      }\n    });\n  };\n\n  Zoom.prototype.touchendZoom = function (startCoords, endCoords, allowX, allowY, touchDuration, rotateValue) {\n    var distanceXnew = endCoords.x - startCoords.x;\n    var distanceYnew = endCoords.y - startCoords.y;\n    var speedX = Math.abs(distanceXnew) / touchDuration + 1;\n    var speedY = Math.abs(distanceYnew) / touchDuration + 1;\n\n    if (speedX > 2) {\n      speedX += 1;\n    }\n\n    if (speedY > 2) {\n      speedY += 1;\n    }\n\n    distanceXnew = distanceXnew * speedX;\n    distanceYnew = distanceYnew * speedY;\n\n    var _LGel = this.core.getSlideItem(this.core.index).find('.lg-img-wrap').first();\n\n    var distance = {};\n    distance.x = this.left + distanceXnew * this.modifierX;\n    distance.y = this.top + distanceYnew * this.modifierY;\n    var possibleSwipeCords = this.getPossibleSwipeDragCords(rotateValue);\n\n    if (Math.abs(distanceXnew) > 15 || Math.abs(distanceYnew) > 15) {\n      if (allowY) {\n        if (this.isBeyondPossibleTop(distance.y, possibleSwipeCords.minY)) {\n          distance.y = possibleSwipeCords.minY;\n        } else if (this.isBeyondPossibleBottom(distance.y, possibleSwipeCords.maxY)) {\n          distance.y = possibleSwipeCords.maxY;\n        }\n      }\n\n      if (allowX) {\n        if (this.isBeyondPossibleLeft(distance.x, possibleSwipeCords.minX)) {\n          distance.x = possibleSwipeCords.minX;\n        } else if (this.isBeyondPossibleRight(distance.x, possibleSwipeCords.maxX)) {\n          distance.x = possibleSwipeCords.maxX;\n        }\n      }\n\n      if (allowY) {\n        this.top = distance.y;\n      } else {\n        distance.y = this.top;\n      }\n\n      if (allowX) {\n        this.left = distance.x;\n      } else {\n        distance.x = this.left;\n      }\n\n      this.setZoomSwipeStyles(_LGel, distance);\n      this.positionChanged = true;\n    }\n  };\n\n  Zoom.prototype.getZoomSwipeCords = function (startCoords, endCoords, allowX, allowY, possibleSwipeCords) {\n    var distance = {};\n\n    if (allowY) {\n      distance.y = this.top + (endCoords.y - startCoords.y) * this.modifierY;\n\n      if (this.isBeyondPossibleTop(distance.y, possibleSwipeCords.minY)) {\n        var diffMinY = possibleSwipeCords.minY - distance.y;\n        distance.y = possibleSwipeCords.minY - diffMinY / 6;\n      } else if (this.isBeyondPossibleBottom(distance.y, possibleSwipeCords.maxY)) {\n        var diffMaxY = distance.y - possibleSwipeCords.maxY;\n        distance.y = possibleSwipeCords.maxY + diffMaxY / 6;\n      }\n    } else {\n      distance.y = this.top;\n    }\n\n    if (allowX) {\n      distance.x = this.left + (endCoords.x - startCoords.x) * this.modifierX;\n\n      if (this.isBeyondPossibleLeft(distance.x, possibleSwipeCords.minX)) {\n        var diffMinX = possibleSwipeCords.minX - distance.x;\n        distance.x = possibleSwipeCords.minX - diffMinX / 6;\n      } else if (this.isBeyondPossibleRight(distance.x, possibleSwipeCords.maxX)) {\n        var difMaxX = distance.x - possibleSwipeCords.maxX;\n        distance.x = possibleSwipeCords.maxX + difMaxX / 6;\n      }\n    } else {\n      distance.x = this.left;\n    }\n\n    return distance;\n  };\n\n  Zoom.prototype.isBeyondPossibleLeft = function (x, minX) {\n    return x >= minX;\n  };\n\n  Zoom.prototype.isBeyondPossibleRight = function (x, maxX) {\n    return x <= maxX;\n  };\n\n  Zoom.prototype.isBeyondPossibleTop = function (y, minY) {\n    return y >= minY;\n  };\n\n  Zoom.prototype.isBeyondPossibleBottom = function (y, maxY) {\n    return y <= maxY;\n  };\n\n  Zoom.prototype.isImageSlide = function () {\n    var currentItem = this.core.galleryItems[this.core.index];\n    return this.core.getSlideType(currentItem) === 'image';\n  };\n\n  Zoom.prototype.getPossibleSwipeDragCords = function (rotateValue, scale) {\n    var dataScale = scale || this.scale || 1;\n    var elDataScale = Math.abs(dataScale);\n    var _a = this.core.mediaContainerPosition,\n        top = _a.top,\n        bottom = _a.bottom;\n    var topBottomSpacing = Math.abs(top - bottom) / 2;\n    var minY = (this.imageYSize - this.containerRect.height) / 2 + topBottomSpacing * this.modifierX;\n    var maxY = this.containerRect.height - this.imageYSize * elDataScale + minY;\n    var minX = (this.imageXSize - this.containerRect.width) / 2;\n    var maxX = this.containerRect.width - this.imageXSize * elDataScale + minX;\n    var possibleSwipeCords = {\n      minY: minY,\n      maxY: maxY,\n      minX: minX,\n      maxX: maxX\n    };\n\n    if (Math.abs(rotateValue) === 90) {\n      possibleSwipeCords = {\n        minY: minX,\n        maxY: maxX,\n        minX: minY,\n        maxX: maxY\n      };\n    }\n\n    return possibleSwipeCords;\n  };\n\n  Zoom.prototype.setZoomSwipeStyles = function (LGel, distance) {\n    LGel.css('transform', 'translate3d(' + distance.x + 'px, ' + distance.y + 'px, 0)');\n  };\n\n  Zoom.prototype.zoomSwipe = function () {\n    var _this = this;\n\n    var startCoords = {};\n    var endCoords = {};\n    var isMoved = false; // Allow x direction drag\n\n    var allowX = false; // Allow Y direction drag\n\n    var allowY = false;\n    var startTime = new Date();\n    var endTime = new Date();\n    var possibleSwipeCords;\n\n    var _LGel;\n\n    var $item = this.core.getSlideItem(this.core.index);\n    this.core.$inner.on('touchstart.lg', function (e) {\n      // Allow zoom only on image\n      if (!_this.isImageSlide()) {\n        return;\n      }\n\n      $item = _this.core.getSlideItem(_this.core.index);\n\n      if ((_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target)) && e.targetTouches.length === 1 && _this.core.outer.hasClass('lg-zoomed')) {\n        e.preventDefault();\n        startTime = new Date();\n        _this.core.touchAction = 'zoomSwipe';\n        _LGel = _this.core.getSlideItem(_this.core.index).find('.lg-img-wrap').first();\n\n        var dragAllowedAxises = _this.getDragAllowedAxises(Math.abs(_this.rotateValue));\n\n        allowY = dragAllowedAxises.allowY;\n        allowX = dragAllowedAxises.allowX;\n\n        if (allowX || allowY) {\n          startCoords = _this.getSwipeCords(e, Math.abs(_this.rotateValue));\n        }\n\n        possibleSwipeCords = _this.getPossibleSwipeDragCords(_this.rotateValue); // reset opacity and transition duration\n\n        _this.core.outer.addClass('lg-zoom-dragging lg-zoom-drag-transition');\n      }\n    });\n    this.core.$inner.on('touchmove.lg', function (e) {\n      if (e.targetTouches.length === 1 && _this.core.touchAction === 'zoomSwipe' && (_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target))) {\n        e.preventDefault();\n        _this.core.touchAction = 'zoomSwipe';\n        endCoords = _this.getSwipeCords(e, Math.abs(_this.rotateValue));\n\n        var distance = _this.getZoomSwipeCords(startCoords, endCoords, allowX, allowY, possibleSwipeCords);\n\n        if (Math.abs(endCoords.x - startCoords.x) > 15 || Math.abs(endCoords.y - startCoords.y) > 15) {\n          isMoved = true;\n\n          _this.setZoomSwipeStyles(_LGel, distance);\n        }\n      }\n    });\n    this.core.$inner.on('touchend.lg', function (e) {\n      if (_this.core.touchAction === 'zoomSwipe' && (_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target))) {\n        _this.core.touchAction = undefined;\n\n        _this.core.outer.removeClass('lg-zoom-dragging');\n\n        if (!isMoved) {\n          return;\n        }\n\n        isMoved = false;\n        endTime = new Date();\n        var touchDuration = endTime.valueOf() - startTime.valueOf();\n\n        _this.touchendZoom(startCoords, endCoords, allowX, allowY, touchDuration, _this.rotateValue);\n      }\n    });\n  };\n\n  Zoom.prototype.zoomDrag = function () {\n    var _this = this;\n\n    var startCoords = {};\n    var endCoords = {};\n    var isDragging = false;\n    var isMoved = false; // Allow x direction drag\n\n    var allowX = false; // Allow Y direction drag\n\n    var allowY = false;\n    var startTime;\n    var endTime;\n    var possibleSwipeCords;\n\n    var _LGel;\n\n    this.core.outer.on('mousedown.lg.zoom', function (e) {\n      // Allow zoom only on image\n      if (!_this.isImageSlide()) {\n        return;\n      }\n\n      var $item = _this.core.getSlideItem(_this.core.index);\n\n      if (_this.$LG(e.target).hasClass('lg-item') || $item.get().contains(e.target)) {\n        startTime = new Date();\n        _LGel = _this.core.getSlideItem(_this.core.index).find('.lg-img-wrap').first();\n\n        var dragAllowedAxises = _this.getDragAllowedAxises(Math.abs(_this.rotateValue));\n\n        allowY = dragAllowedAxises.allowY;\n        allowX = dragAllowedAxises.allowX;\n\n        if (_this.core.outer.hasClass('lg-zoomed')) {\n          if (_this.$LG(e.target).hasClass('lg-object') && (allowX || allowY)) {\n            e.preventDefault();\n            startCoords = _this.getDragCords(e, Math.abs(_this.rotateValue));\n            possibleSwipeCords = _this.getPossibleSwipeDragCords(_this.rotateValue);\n            isDragging = true; // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723\n\n            _this.core.outer.get().scrollLeft += 1;\n            _this.core.outer.get().scrollLeft -= 1;\n\n            _this.core.outer.removeClass('lg-grab').addClass('lg-grabbing lg-zoom-drag-transition lg-zoom-dragging'); // reset opacity and transition duration\n\n          }\n        }\n      }\n    });\n    this.$LG(window).on(\"mousemove.lg.zoom.global\" + this.core.lgId, function (e) {\n      if (isDragging) {\n        isMoved = true;\n        endCoords = _this.getDragCords(e, Math.abs(_this.rotateValue));\n\n        var distance = _this.getZoomSwipeCords(startCoords, endCoords, allowX, allowY, possibleSwipeCords);\n\n        _this.setZoomSwipeStyles(_LGel, distance);\n      }\n    });\n    this.$LG(window).on(\"mouseup.lg.zoom.global\" + this.core.lgId, function (e) {\n      if (isDragging) {\n        endTime = new Date();\n        isDragging = false;\n\n        _this.core.outer.removeClass('lg-zoom-dragging'); // Fix for chrome mouse move on click\n\n\n        if (isMoved && (startCoords.x !== endCoords.x || startCoords.y !== endCoords.y)) {\n          endCoords = _this.getDragCords(e, Math.abs(_this.rotateValue));\n          var touchDuration = endTime.valueOf() - startTime.valueOf();\n\n          _this.touchendZoom(startCoords, endCoords, allowX, allowY, touchDuration, _this.rotateValue);\n        }\n\n        isMoved = false;\n      }\n\n      _this.core.outer.removeClass('lg-grabbing').addClass('lg-grab');\n    });\n  };\n\n  Zoom.prototype.closeGallery = function () {\n    this.resetZoom();\n  };\n\n  Zoom.prototype.destroy = function () {\n    // Unbind all events added by lightGallery zoom plugin\n    this.$LG(window).off(\".lg.zoom.global\" + this.core.lgId);\n    this.core.LGel.off('.lg.zoom');\n    this.core.LGel.off('.zoom');\n    clearTimeout(this.zoomableTimeout);\n    this.zoomableTimeout = false;\n  };\n\n  return Zoom;\n}();\n\nexport default Zoom; //# sourceMappingURL=lg-zoom.es5.js.map","map":null,"metadata":{},"sourceType":"module"}